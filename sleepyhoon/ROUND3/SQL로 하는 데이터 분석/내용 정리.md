# SQL로 하는 데이터 분석

### GUI 와 CLI 의 차이

GUI는 우리가 흔히 윈도우에서 사용하는 graphic UI를 의미하고

CLI는 리눅스같은 운영체제에서 사용하는 commend UI이다.

### CLI의 장점?

- 디자인보다는 성능에 집중해서 더 빠르게 실행가능
- 사용법이 좀 더 명확하다

→ 쉽게 말해서 단순, 명확하다는 장점이 존재한다.

## 기본키의 종류

### **1. Natural Key**

실제로 어떤 개체가 갖고 있는 속성을 나타내는 컬럼이 Primary Key가 됐을 때 이를 Natural Key라고 합니다. 사람은 주민등록번호로 특정 인물을 식별할 수 있습니다. 우리가 읽는 책은 [ISBN](https://en.wikipedia.org/wiki/International_Standard_Book_Number)이라고 하는 번호로 특정할 수 있구요. 바로 이런 속성을 나타내는 컬럼이 Primary Key가 되면 Natural Key라고 합니다.

### ****2. Surrogate Key****

단지 Primary Key로 사용하기 위해 **인위적으로 생성한** 컬럼이다. 이렇게 어떤 개체의 실제 속성은 아니지만 Primary Key로 쓰기 위해 추가한 컬럼을 Surrogate Key라고 합니다.  이런 Surrogate Key에는 주로 1부터 순차적으로 증가하는 숫자가 들어가게 된다. → mysql에서 Auto Increment에 해당하는 설명이다. 이거 체크하면 사용자가 굳이 신경쓰지 않아도 key값이 자동으로 +1된다. DBMS가 자동으로 관리해주는 값이라는 뜻

딱히 무엇을 써야한다는 정답은 없지만 natural key의 경우에는 수정될 때 마다 모든 row의 값을 수정해야 된다는 단점이 있어(사람의 주민번호를 변경하는 드문 경우) 보통은 Surrogate Key를 사용한다.

id값은 값을 기본키로 지정하면 자연스럽게 not null도 자동으로 체크된다. 당연한 말.

### SQL문에서 테이블 명을 언급할 때..

```sql
select * from member # 테이블명이 member인 경우
```

와 같이 나타내는 것이 일반적이다. 나도 그렇게 했고, 그런데 실무에서는 데이터베이스마다 같은 이름의 테이블이 있는 경우가 있기 때문에 에러가 발생할 수 있다고 한다. 그래서

```sql
select * from copang_main.member # DB이름이 copang_main
```

[DB이름].[테이블이름] 과 같이 나타내는 것이 더 안전하다고 한다.

아니면 차라리 SQL문 시작할 때

```sql
use copang_main
```

과 같이 아예 특정 DB를 사용하겠다고 선언해버리면 테이블명만 사용해서 SQL문을 작성할 수 있다.

## 조건문 where 사용

### 여러가지 where 사용법

```sql
select * from member where age (not) between 30 and 39;
```

나이가 30대인 사람들만 검색한다. not이면 30대를 제외하고 조회한다.

```sql
select * from member where address like '서울%';
```

주소가 서울로 시작하는 모든 사람들을 조회한다. ‘서울_’을 사용할 경우 서울로 시작하는 3글자만 조회한다.

- 같지 않음을 나타내는 ≠,<>
- 이 중에 있으면 참을 나타내는 in 연산자

등등 자유롭게 사용할 수 있다.

- 기타 유용한 함수들 (DATE 관련)
    
    # **1. 연도, 월, 일 추출하기**
    
    DATE 타입의 값에서 연도(year)만, 혹은 월(month)만, 혹은 일(day)만 추출할 수 있습니다. 어떻게 할 수 있는지 하나씩 살펴볼게요.
    
    ## **(1) 1992년에 태어난 회원들만 조회하기**
    
    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3165&directory=48w4h37jw-1.png&name=48w4h37jw-1.png
    
    위 그림에서처럼 `YEAR()` 함수를 사용하면 날짜 값에서 연도만 뽑아낼 수 있습니다.
    
    ## **(2) 여름(6, 7, 8월)에 가입한 회원들만 조회하기**
    
    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3165&directory=mmagesncb-2.png&name=mmagesncb-2.png
    
    위 그림처럼 `MONTH()` 함수를 사용하면 날짜값에서 월만 뽑아낼 수 있습니다. 지금 그 뒤에는 이전 노트에서 배운 **[IN 조건 표현식](https://www.codeit.kr/topics/data-analysis-using-sql/lessons/3164)**을 사용해봤습니다. 위 그림을 보니 여름에 가입한 회원들만 잘 조회되네요.
    
    ## **(3) 각 달의 후반부(15일~31일)에 가입했던 회원들만 조회하기**
    
    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3165&directory=p7xr3l32q-3.png&name=p7xr3l32q-3.png
    
    `DAYOFMONTH()` 함수는 날짜값에서 일만 뽑아낼 수 있습니다. 그 뒤에는 이전에 배운 `BETWEEN a AND b` 구문을 사용해봤습니다. 각 달의 후반부(15일~31일) 사이에 가입한 회원들만 잘 조회되네요.
    
    # **2. 날짜 간의 차이 구하기**
    
    날짜 간의 차이를 구하는 함수도 있습니다. `DATEDIFF()`라는 함수인데요. 여기서 DATE는 날짜, DIFF는 Difference의 줄임말로 '차이'라는 뜻입니다.
    
    **`DATEDIFF(날짜 a, 날짜 b)`**를 사용하면 '날짜 a - 날짜 b'를 해서 그 차이 일수를 알려줍니다. 예를 들어,
    
    `DATEDIFF(’2018-01-05’, ’2018-01-03’)`의 값은 2입니다.
    
    `member` 테이블에서 각 회원이 가입한 일자가 2019년 1월 1일을 기준으로 몇 일 이후인지를 알아보겠습니다. 아래 SQL 문을 자세히 살펴보세요.
    
    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3165&directory=sp4sfuycq-4.png&name=sp4sfuycq-4.png
    
    실행결과에는 총 3개의 컬럼이 보입니다. `email`, `sign_up_day`, 그리고 `sign_up_day`에서 2019년 1월 1일을 뺀 값이 담긴 컬럼, 이렇게 3개인데요. 꼭 테이블에 원래 있던 컬럼이 아니더라도 조회할 때는 이런 식으로 새로운 컬럼을 붙여서 볼 수도 있습니다.
    
    지금 보니까 가장 최근에는 cowboy라는 회원이 가입했고, 가입한지 가장 오래된 회원은 2011년에 가입한 xMan_series라는 회원이라는 것을 알 수 있습니다.
    
    그리고 이것 말고도 오늘 날짜를 기준으로 살펴보는 것도 가능한데요. 오늘 날짜를 구하는 함수는 `CURDATE()`입니다.
    
    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3165&directory=1jvc5p68w-5.png&name=1jvc5p68w-5.png
    
    이 노트가 작성된 날짜는 2020년 6월 2일입니다. 위 그림을 보니 오늘 날짜와의 차이도 잘 출력되었죠?
    
    이번엔 회원들이 몇 살이었을 때 코팡에 가입했는지를 알아볼까요? **가입일(sign_up_day)-생일(birthday)** 값을, 1년이 365일이니까 365로 나눠주면 각 회원이 몇 살일 때, 코팡에 가입했는지 알 수 있습니다.
    
    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3165&directory=4thidagr7-6.png&name=4thidagr7-6.png
    
    결과를 보니까 많은 회원들이 20대, 30대일 때 많이 가입을 했네요.
    
    # **3. 날짜 더하기 빼기**
    
    날짜에서 며칠을 더하고 빼는 것도 가능한데요. 더하는 함수는 **`DATE_ADD()`**, 빼는 함수는 **`DATE_SUB()`**입니다.
    
    예를 들어, 가입일(`sign_up_day`) 기준으로 300일 이후의 날짜를 구하려면 이렇게 쓰면 됩니다.
    
    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3165&directory=9a9ivyn32-8.png&name=9a9ivyn32-8.png
    
    지금 **`DATE_ADD(sign_up_day, INTERVAL 300 DAY)`**라고 적힌 부분은 `sign_up_day` 컬럼의 값에 300일을 더한 날짜를 나타냅니다.
    
    만약 가입일(`sign_up_day`) 기준 250일 이전의 날짜를 구하고 싶으면 이렇게 쓰면 됩니다.
    
    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3165&directory=69fx717ms-9.png&name=69fx717ms-9.png
    
    특정 날짜에서 몇 일 후, 몇 일 전 날짜를 구해야할 때 이 함수들을 쓰면 유용하겠죠?
    
    # **4. UNIX Timestamp 값**
    
    지금 `member` 테이블에서 날짜를 나타내는 컬럼(`birthday`, `sign_up_day`)은 있지만, 시간을 별도로 나타내는 컬럼은 없습니다. 날짜뿐만 아니라 시간까지 포함하는 컬럼이라면 DATETIME이라는 데이터 타입을 사용해야하는데요. DATETIME 타입의 컬럼에는 보통 '2018-12-31 23:54:59’ 이런 식으로 값들이 저장되어 있습니다.
    
    그런데 문제는 어떤 테이블에는 날짜와 시간이 이렇게 예쁜 형식으로 적혀있는게 아니라, 1553526000 이런 식으로 상당히 큰 숫자값이 적혀있는 경우들이 꽤 많다는 겁니다. 이것 또한 날짜와 시간을 나타내는 값인데요. 이런 형식의 날짜시간 값을 UNIX Timestamp라고 합니다. UNIX Timestamp는 특정 날짜의 특정 시간을, 1970년 1월 1일을 기준으로, 총 몇 초가 지났는지로 나타낸 값입니다.
    
    정확히 어떤 건지 보여드리겠습니다. DATE 타입의 값을 Unix Timestamp로 바꿔주는 함수가 있는데요. `sign_up_day` 컬럼의 날짜값을 한번 Unix Timestamp로 변환해보겠습니다.
    
    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3165&directory=n2sajhxwc-10.png&name=n2sajhxwc-10.png
    
    `UNIX_TIMESTAMP()`라는 함수를 쓰면 되는데요. 지금 빨간 박스 안에 상당히 큰 숫자값들이 보입니다. 이 값들은 모두 각 날짜가 1970년 1월 1일을 기준으로 몇 초가 지난 것인지를 나타냅니다. 실무에서 여러분은 깔끔한 형식의 날짜 또는 시간뿐만 아니라 이런 Unix Timestamp를 보게될 수도 있습니다.
    
    만약 여러분이 테이블에서 이런 Unix timestamp를 보게 된다면 이걸 사람이 읽을 수 있는 날짜 형태로 바꿔서 보면 되는데요.
    
    그럴 때는 `FROM_UNIXTIME()` 함수를 사용하면 됩니다.
    
    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3165&directory=pn4vtm6i4-11.png&name=pn4vtm6i4-11.png
    
    Unix timestamp를 다시 집어넣었더니 원래 날짜가 그대로 잘 나왔습니다. 대신 이번엔 시간 정보도 포함해서(00:00:00) 출력되었네요.
    
    혹시 날짜와 시간을 나타내는 컬럼이라고 하는데 뭔가 큰 숫자가 들어있다면, Unix timestamp가 아닌지 의심해보세요. 그리고 방금 배운 함수로 DATETIME 형식으로 변환해서 보시면 됩니다.
    
    # 
    
    자, 이때까지 DATE 타입의 값들을 다룰 수 있는 유용한 함수들을 알아보았습니다. 이밖에도 '시간을 나타내는 TIME 타입', 방금 설명했던 '날짜, 시간을 함께 나타내는 DATETIME 타입', 그리고 이것들과 관련된 또다른 함수들도 많습니다. 혹시 이런 내용들에 관해 더 자세하게 알고 싶은 분들은 아래 MySQL 공식 매뉴얼을 참조하세요.
    
    - 날짜, 시간 관련 데이터 타입 : https://dev.mysql.com/doc/refman/8.0/en/date-and-time-types.html
    - 날짜, 시간 관련 함수 : https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html

### 조건문에서 복잡한 조건을 사용할 때…

반드시 괄호를 작성해서 먼저 실행해야 할 것들을 묶어두는 것이 중요하다. 가독성에도 좋고 개발자도 혼란없이 잘 작성할 수 있음.

### 이스케이핑(escaping)?

원래 특정 의미('임의의 길이를 가진 문자열')를 나타내던 문자(`%`)를 그 특정 의미가 아니라, 일반적인 문자처럼 취급하는 행위를 **이스케이핑(escaping)**이라고 합니다.

예를 들어 정말 문자열 %이 포함된 문자열을 원한다면 ‘\%’와 같이 표현하여 나타낼 수 있고, \_,\”로 _와 “ 도 표현할 수 있다.

### 문자의 대소문자 구별하기

본래 문자열을 비교하는 like 연산자를 사용할 때

```sql
... where sentence like '%g%'
```

와 같이 표현하면 g,G 구분없이 결과를 출력해준다. mysql의 기본 설정이 대소문자를 구별하지 않기 때문이다. 나의 의도는 대문자 G는 포함하면 안되기에 대소문자를 구별해야한다. 그럴 경우  `%g%` 앞에 `BINARY`라는 단어를 붙인다.

```sql
... where sentence like binary '%g%'
```

g,G를 2진수로 비교하여 대소문자를 구별 할 수 있게 해준다.

## 정렬 order by 사용

### 여러가지 기준으로 정렬

```sql
select sign_up_day, email from member
order by year(sign_up_day) desc, email asc;
```

year(sign_up_day) desc 을 기준으로 1번째 정렬을 하고, 같은 값이라면 email asc을 이용해서 2번째 정렬을 진행한다.

### 정렬 시 주의사항?

int형 변수를 기준으로 정렬하면 우리가 의도하는대로 잘 정렬되지만, text 변수와 같은 값으로 정렬 할 때는 우리가 의도한 대로 되지 않는 경우가 많다. 그래서 cast() 함수를 이용해서 값을 강제로 int형으로 변환해서 정렬해준다.

```sql
select * from member order by cast(data as signed) asc;
```

만약 소수점까지 이용해야 한다면

```sql
select * from member order by cast(data as demical) asc;
```

을 사용한다.

### 데이터 개수 제한

select문을 이용해서 몇개만 추리고 싶은 경우에는 limit을 사용한다.

```sql
select ....
limit 10;
```

혹은 더 복잡한 표현도 가능한데, row 8번째부터 2개만 보고싶다면(row는 0번째부터 시작)

```sql
select ...
limit 8,2;
```

와 같이 나타낼 수 있다.