# Codeit Git 강의 요약

### repository

.git 디렉토리가 숨겨져 있는 디렉토리를 말한다. 여기에는 프로젝트 디렉토리의 버전별 모습들이 모두 저장되어 언제든지 불러올 수 있다.

### commit

프로젝트 디렉토리의 특정 모습을 하나의 버전으로 남기는 행위, 또는 결과물을 커밋이라고 하고, 커밋이 저장되는 곳을 repository라고 한다.

```cpp
git init -> 빈 레포지토리를 만들어준다.
```

commit 하기 전에는 사용자의 이름과 이메일을 추가해줘야함.

```cpp
git config user.name "codeit"
git config user.email "example@codeit.kr"
git commit -m "message..." // 커밋 메세지를 반드시 남겨야함.
```

그 다음, add를 하여 무엇을 commit 할것인지 정해줘야함.

```cpp
git add "파일 명"
git add . // 변경된 파일 모두 staging area에 추
```

## Working directory, Staging Area, repository

- 설명
    
    첫 번째 작업 영역인 **working directory**는 작업을 하는 프로젝트 디렉토리를 말합니다. 그러니까 지금 상황에서는 **MathTool 디렉토리**가 working directory입니다.
    
    두 번째 작업 영역인 **staging area**는 **git add**를 한 파일들이 존재하는 영역입니다. 커밋을 하게되면 **staging area**에 있는 파일들만 커밋에 반영됩니다.
    
    세 번째 작업 영역인 **repository**는 working directory의 변경 이력들이 저장되어 있는 영역입니다. 그러니까 커밋들이 저장되는 영역이라는 뜻인데요. 조금 풀어서 설명해볼게요.
    
    - working directory에서 뭔가 작업을 하고,
    - 작업한 파일들을 **git add** 해주고,
    - 커밋을 하면 staging area에 있던 파일들의 모습이 마치 영화의 한 장면, 스냅샷(snapshot)처럼 이 repository에 저장되는 겁니다.
    
    그리고 ['02. repository 만들기' 영상](https://www.codeit.kr/learn/2886/)에서 본 것처럼 실제로는 MathTool 디렉토리 안에 숨겨져 있던 **.git 디렉토리**가 repository입니다.
    
    3가지 작업 영역이 잘 이해되시나요? 좀더 잘 이해하기 위해 다음 그림을 봅시다.
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/git%20%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3.001.png?1587714756098
    
    왼쪽부터 순서대로 working directory, staging area, repository가 있습니다. 다음과 같은 작업을 한 상태를 나타내는 그림인데요.
    
    1. working directory에서 A.txt 파일과 B.txt 파일을 작성하고
    2. **git add A.txt**와 **git add B.txt**를 실행해서 A.txt, B.txt 둘다 staging area에 올렸습니다.
    3. 그 다음 **git commit -m "Ver_1"**를 실행해서 **staging area에 있는 파일들을 가져와 커밋으로 남겼습니다.**
    
    Git에서 커밋을 할 때 어떤 식으로 일이 진행되는 건지 좀 이해되시죠?
    
    자, 작업을 좀더 해볼까요?
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/git%20%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3.002.png?1587714789711
    
    이전 그림에서 작업을 좀더 하고 나서의 모습인데요. 다음과 같은 작업을 추가적으로 했습니다.
    
    1. working directory에서 A.txt 파일 내용에 Python~이라는 단어를 추가, B.txt 파일 내용에 Morning!이라는 단어를 추가했습니다.
    2. 그런데 이번에는 **git add B.txt**만 실행해서 B.txt 파일만 staging area에 올렸습니다.
    3. 그 다음 **git commit -m "Ver_2"**로 두 번째 커밋을 했습니다.
    
    **이전 그림과 다른 점은 A.txt는 staging area에 올리지 않고, B.txt만 staging area에 올렸다는 점입니다.** 그랬더니 지금 repository에서 그 결과가 어떤가요? Ver_2 커밋을 보면 지금
    
    - A.txt는 staging area에 있던 모습, 그러니까 **수정하기 이전의 모습**이 Ver_2 커밋에 반영되었고
    - B.txt도 staging area에 있던 모습, 하지만 A.txt와는 달리 **수정한 이후의 모습**이 Ver_2 커밋에 반영되었습니다.
    
    A.txt, B.txt 둘다 working directory에서 수정했다는 사실은 같지만, **staging area에 올렸는지 여부에 따라 그 최신 모습이 커밋에 반영되는지가 달라지는 겁니다.** 바로 이 점이 Git을 사용할 때 잘 알고 기억해야하는 부분입니다.
    
    그런데 staging area가 굳이 왜 필요할까요? working directory에서 작업을 하고 git add할 필요없이 바로 커밋해버리는 구조가 더 편할 것 같은데 말이죠. 하지만 꼭 그렇지는 않습니다. 방금처럼 A.txt와 B.txt 파일을 둘다 수정했더라도 두 파일 모두 그 최신 모습을 다음 커밋에 반영하고 싶지 않을 수도 있습니다. 방금처럼 B.txt의 최신 모습만 그 다음 커밋에 반영하고 싶을 수도 있는 거죠. 이런 상황은 실제로 꽤 자주 있습니다. 만약 staging area가 없다면 원하는 것들만 선별적으로 커밋에 반영할 수 없게 됩니다. 그럼 좀더 세밀한 버전 관리를 할 수 없게 되는 거죠. 왜 staging area가 필요한지 알겠죠?
    
    자, 이때까지 Git의 3가지 작업 영역과 그 관계에 대해서 알아봤는데요. 이 부분은 몇 번을 강조해도 지나치지 않을만큼 중요한 핵심 개념입니다. 이 개념을 완벽히 이해해야 나머지 내용을 배우는데 어려움이 없습니다. 꼭 제대로 이해하고 넘어가세요.
    
    참고로 working directory는 working tree라고 하기도 하고, staging area는 index라고 할 때도 있습니다. 혹시 다른 곳에서 working tree, index 이런 단어를 쓰더라도 결국 다 우리가 배운 작업 영역들이니까 당황하지 마세요!
    

### file 만들기

```cpp
touch day1
```

day1이라는 파일을 생성할 수 있음.

## git이 보는 파일의 4가지 상태

- 상태
    
    일단 Git에서 파일들은 크게 다음 2가지 상태를 가집니다.
    
    - Untracked 상태
    - Tracked 상태
    
    그리고 **Tracked 상태는 다시 아래와 같은 3가지 상태로 나눌 수 있구요.**
    
    - Staged 상태
    - Unmodified 상태
    - Modified 상태
    
    각 상태를 순서대로 설명해드릴게요.
    
    **1. Untracked 상태 - git add를 하지 않은 상태**
    
    Untracked는 '추적되지 않고 있는'이라는 뜻입니다. 이 상태는 파일이 Git에 의해서 그 변동사항이 전혀 추적되고 있지 않는 상태를 뜻합니다. 예를 들어, 파일을 새로 생성하고 그 파일을 한 번도 git add 해주지 않았다면 이 상태입니다.
    
    **2. Tracked 상태 - git add를 해준 상**
    
    파일이 Git에 의해 그 변동사항이 추적되고 있는 상태입니다. 이 상태는 다시 그 특성에 따라 3가지 상태로 나뉩니다. 하나씩 설명할게요.
    
    (1) Staged 상태
    
    파일의 내용이 수정되고나서, staging area에 올라와있는 상태를 Staged(스테이징된, stage area에 올려진) 상태라고 합니다.
    
    > 새로 생성한 파일에 내용을 쓰고 git add를 해주거나
    > 
    
    > 한 번이라도 커밋에 포함됐었던 파일이라도 내용을 수정하고 git add를 해주면 이 상태입니다.
    > 
    
    (2) Unmodified 상태
    
    현재 파일의 내용이 최신 커밋의 모습과 비교했을 때 전혀 바뀐 게 없는 상태면 그 파일은 Unmodified(수정되지 않은, 변한 게 없는) 상태입니다. 커밋을 하고 난 직후에는 working directory 안의 모든 파일들이 이 상태가 됩니다.
    
    (3) Modified 상태
    
    최신 커밋의 모습과 비교했을 때 조금이라도 바뀐 내용이 있는 상태면 그 파일은 Modified(수정된) 상태입니다.
    
    이렇게 Git에서 파일은 매 순간 4가지 상태 중 하나의 상태에 있게 됩니다. 이 내용을 그림으로 정리하면 아래와 같습니다.
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/32-1.png?1586769805567
    
    어떤 경우에, 어떻게 상태 전환이 발생하는지 주의깊게 살펴보세요. 각 경우를 설명하자면 아래 내용과 같습니다.
    
    - Add the file : Untracked 상태의 파일을 처음으로 git add 해주면 Staged 상태가 됩니다.
    - Edit the file : 최신 커밋과 비교했을 때 차이가 없는 Unmodified 상태의 파일의 내용을 수정하면 Modified 상태가 됩니다.
    - Stage the file : Modified 상태의 파일을 git add 해주면 Staged 상태가 됩니다.
    - Remove the file : 파일을 삭제하면 당연히 Git에서 더이상 인식하지 않겠죠?
    - Commit : 커밋을 하면 staging area에 있던 파일들이 커밋에 반영되고, 이제 모든 파일들은 최신 커밋과 차이가 없게 되니까 Unmodified 상태가 됩니다.

### git add 취소하기

```cpp
git reset "파일 명"
```

stage에 올라간 파일을 내려오게 할 수 있음. 하지만 수정된 내용은 여전히 존재.

- github의 레포지토리는 원격 레포지토리 라고 하고, 내 컴퓨터에서의 레포지토리는 로컬 레포지토리라고한다. 이 둘의 이름은 서로 다를 수 있다.
- 로컬 레포지토리에서 새로운 커밋이 발생하면 이를 원격 레포지토리에도 반영해야 한다. 이때 push 명령어를 사용한다.

```cpp
git push
```

- 반대로 원격 레포지토리에 새로운 커밋이 발생하면 이를 로컬 레포지토리에 반영해야한다. 이때 pull 명령어를 사용한다.

```cpp
git pull
```

- 기본적으로 자기 자신이 만든 레포지토리는 자기만 git push를 할 수 있으나, 다른 사람과 협업을 해야하는 상황이라면 invite collaborator를 해서 함께 작업할 수 있다.

## Commit에 대해서

- commit 히스토리 보기 :

```cpp
git show [커밋아이디 앞 4자리 정도] : 입력하면 해당 커밋과 그 전 커밋의 차이점을 잘 보여준다.
git log : 지금까지 한 commit을 보여준다.
```

- -m 옵션 없이 커밋 메세지 남기기 :

```cpp
git commit
```

아무것도 없이 이렇게만 작성하면 git bash에서 따로 message를 작성하는 편집기가 열린다. (주로 vim일 것임) 그럼 vim 문법에 따라서 작성할 수 있다.
→ i를 누르면 insert 모드가 켜져 글씨를 작성할 수 있고, 작성이 끝나면 esc를 누르고 :wq를 작성한뒤 엔터를 치면 작성이 완료된다.

- 만약 최선 커밋이 맘에 안들어서 수정하고 싶은 경우에는 파일을 수정한 뒤,

```cpp
git commit --amend
```

를 입력하면 마찬가지로 vim 편집기가 뜬다. 여기서 커밋 메세지도 수정할 수 있음. 지금 커밋을 수정할 수 있다.(커밋id도 바뀜)

- 커밋 생성시 가이드라인
- 가이드 라인 모음
    
    # **1. 커밋 메시지 작성 가이드라인**
    
    **(1) 커밋 메시지의 제목과 상세 설명 사이에는 한 줄을 비워두세요.**
    
    https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=2909&directory=osoq95w0h-37-1.png&name=osoq95w0h-37-1.png
    
    이전 영상에서 커밋 메시지를 남길 때 봤던 장면인데 기억나시나요? 지금 1번이 커밋 메시지의 **제목(title)**, 2번이 커밋 메시지의 **상세 내용(body)**이라고 생각하시면 됩니다. 뭔가 상세한 설명이 필요한 커밋인 경우에는 커밋 메시지 한 줄보다는 이런 식으로 제목과 상세 내용으로 구분해서 적어주면 좋은데요. 이럴 때 제목과 상세 내용 사이에 한 줄을 띄워놓아야 나중에 커밋 메시지를 볼 때 좀더 편하게 볼 수 있습니다. 그리고 이렇게 비어있는 한 줄을 두는 것이 **[Git에서 공식적으로 권장하는 사항](https://git-scm.com/docs/git-commit#_discussion)**(예를 들어, 특정 명령어가 이 한 줄을 기준으로 제목과 상세 내용을 구분해서 사용한다고 합니다)이기도 하니까 꼭 지켜주세요.
    
    **(2) 커밋 메시지의 제목 뒤에 온점(.)을 붙이지 마세요.**
    
    **(3) 커밋 메시지의 제목의 첫 번째 알파벳은 대문자로 작성하세요.**
    
    **(4) 커밋 메시지의 제목은 명령조로 작성하세요.(Fix it / ~~Fixed it / Fixes it~~)**
    
    **(5) 커밋의 상세 내용에는 이런 걸 적으면 좋습니다.**
    
    - 왜 커밋을 했는지
    - 어떤 문제가 있었고
    - 적용한 해결책이 어떤 효과를 가지는지
    
    **(6) 다른 사람들이 자신의 코드를 바로 이해할 수 있다고 가정하지 말고 최대한 친절하게 작성하세요.**
    
    어떤가요? 이런 것들을 신경쓰면서 커밋 메시지를 남겨야 남들이 여러분이 한 커밋에 대해 더 잘 이해할 수 있겠죠?
    
    그런데 사실 커밋 메시지를 작성하는 방법뿐만 아니라 커밋을 남기는 것 자체에 관해서도 일종의 가이드라인이 있습니다. 그것들을 정리해보면 아래와 같은데요.
    
    # **2. 커밋할 때 알아야할 가이드라인**
    
    **(1) 하나의 커밋에는 하나의 수정사항, 하나의 이슈(issue)를 해결한 내용만 남기도록 하세요. 다양하게 수정을 하고나서 하나의 커밋으로 남기는 것은 좋지 않습니다. 하나의 커밋이 하나의 사실만을 갖고 있어야 나중에 이해하기 쉽습니다.**
    
    이 말은 결국 최대한 작은 단위의 변화를 기준으로 커밋을 하라는 뜻입니다. 예를 들어 여러분이 A라는 파일에서 기존 함수를 3개 삭제하고, B라는 파일에서 기존 함수 2개를 삭제, C라는 파일에서 기존 함수를 1개 삭제했다고 합시다. 그 다음 프로그램을 실행해봤는데 오류가 생겼다면 과연 A, B, C 파일 중 무엇때문에 문제가 생긴건지 일일이 확인해보지 않는 이상 알 수 없겠죠? 이처럼 다양한 종류의 수정을 다 하고나서야 커밋을 하면 바로 그 다음에 프로그램에 문제가 생겼을 때 그 원인을 파악하는데 시간이 더 오래 걸립니다. 그리고 이렇게 하면 커밋 간의 독립성이 사라져서 나중에 프로젝트의 이력을 파악하는 일도 어려워지기도 하죠.
    
    하지만 어느 정도의 수정사항을 하나의 단위로 볼 것인지는 상황에 따라 조금씩 다를 수 있습니다. 회사의 규칙에 따라 다를 수도 있구요. 어찌 됐든 너무 많은 작업의 결과를 하나의 커밋으로 담지 않아야겠다는 생각을 하면서 커밋을 해야합니다.
    
    **(2) 현재 프로젝트 디렉토리의 상태가 그 내부의 전체 코드를 실행했을 때 에러가 발생하지 않는 상태인 경우에만 커밋을 하도록 하세요. 나중에 동료 개발자가 특정 커밋의 코드로 실행했을 때 에러가 발생한다면 혼란을 줄 수 있습니다.**
    
    커밋으로 보관된 특정 시점의 전체 코드는 항상 문제없이 실행되는 상태여야 합니다. 이미 과거의 커밋이 되어버렸다고 우리에게 쓸모없는 커밋이 되는 건 절대 아닙니다. 과거의 커밋이라도
    
    - 과거 버전의 프로그램을 사용해야하거나
    - 과거 커밋을 시작점으로 한 다른 방향의 별도 프로젝트를 시작하거나
    - 아예 그 커밋으로 현재 프로젝트를 리셋할 수도 있습니다.
    
    따라서 매 커밋의 코드들은 항상 정상 실행되는 상태의 코드여야 합니다. 그렇지 않으면 나중에 그 커밋을 위와 같은 용도로 사용하려고 할 때 문제가 생길 수 있습니다. 그리고 협업하는 상황을 생각해봐도 내가 남긴 커밋을 동료 개발자가 실행해봤는데 에러가 나고 실행이 되지 않는다면 좀 민망하겠죠? 따라서 커밋을 하기 전에 프로그램이 정상 실행되는지 점검하고 커밋하는 것이 좋습니다.
    
    자, 이때까지 커밋에 관한 가이드라인들을 살펴봤습니다. 사실 이런 가이드라인은 회사마다 다를 수 있고, 절대적인 규칙이 있는 것도 아닙니다. 어떤 경우든지 본인이 다니는 회사의 가이드라인을 잘 준수하는 것이 좋겠죠? 혹시 가이드라인이 없다고 할지라도
    
    - 나중에 다시 봤을 때 이해하는데 어려움이 없도록
    - 다른 동료 개발자와 협업하는 데 방해가 되지 않도록
    
    커밋을 남기고, 그 때마다 커밋 메시지를 잘 작성하는 것이 중요합니다.
    
- 만약 git 명령어가 너무 길어서 쓰기 힘든 경우에는 alias, 즉 별명을 지어줄 수 있다.

```cpp
$ git config alias.history 'log --pretty=oneline’
```

과 같이 입력하면 git log --pretty=oneline 와 git history는 같은 의미가 된다. 여기서 history를 git 공식 명령어는 아니다.

- commit 간의 차이를 보고 싶다면 다음 명령어를 입력한다.

```cpp
git diff [이전커밋id] [이후커밋id]
```

그럼 git show를 실행했을 때와 비슷하게 둘의 차이점을 알 수 있음.

- HEAD?

어떤 커밋을 가리키는 존재. 기본적으로는 제일 최선 커밋을 가리키나 내가 변경해줄 수 있음. HEAD가 어느 커밋을 가리키냐에 따라서 working directory가 바뀐다.

- 이전 커밋으로 git reset 하고 싶은 경우에는

```cpp
git reset --hard [가고싶은커밋id]
+ 커밋아이디 대신 HEAD^, HEAD~2,3,4,,, 사용가능.
HEAD^ : 헤드가 가리키는 바로 전 커밋
HEAD~X : 헤드 전 X번째 커
```

을 입력하면 working directory도 같이 그 당시 커밋할 때로 변한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/956ff5d2-3ef3-459b-abde-09ddbf04fc0f/c72e5b1d-4034-437e-8c75-5573208a94df/Untitled.png)

—hard의 경우에는 로컬 디렉토리 내용이 모두 지워지기 때문에 되돌릴 수 없으므로 권장되지는 않는다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/956ff5d2-3ef3-459b-abde-09ddbf04fc0f/63d418d3-6b4a-4441-8ead-1bf466e2126f/Untitled.png)

- 이 내용은 특히 어려우니 반복해서 학습을 해야할듯. 만약 —hard 옵션을 잘 못써서 데이터가 날라가도 깃허브에서 다시 git pull 해오면 원상복귀 된다. 이거 안해놨으면 노답.

---

- 만약 git 에 tag를 달아서 쉽게 관리하고 싶은 경우에는

```cpp
git tag [태그이름] [태그 달 커밋id]
git tag : 모든 tag 모아보기
git show [태그이름] : 그 태그에 대해서 자세히 출력하기
git tag -d [태그이름] : 태그 없애기

git diff Ver1 Ver2(예시) 와 같이 커밋과 동일하게 사용 가능하다.
```

- 커밋 관련 명령어 정리
- 정리
    - **git log** : 커밋 히스토리를 출력
    - **git log --pretty=oneline** : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 **[이 링크](https://git-scm.com/docs/pretty-formats)**를 참고하세요.
    - **git show [커밋 아이디]** : 특정 커밋에서 어떤 변경사항이 있었는지 확인
    - **git commit --amend** : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦
    - **git config alias.[별명] [커맨드]** : 길이가 긴 커맨드에 별명을 붙여서 이후로 별명으로 해당 커맨드를 실행할 수 있도록 설정
    - **git diff [커밋 A의 아이디] [커밋 B의 아이디]** : 두 커밋 간의 차이 비교
    - **git reset [옵션] [커밋 아이디]** : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)
        
        (1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)
        
        (2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)
        
        (3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)
        
        그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨
        
    - **git tag [태그 이름] [커밋 아이디]** : 특정 커밋에 태그를 붙임

# branch

- 기본 branch 관련 명령어들

```cpp
git branch [브랜치이름] : 새로운 브랜치 만들기 (현재 head가 가리키고 있는 커밋에서)
git branch : 현재 브랜치가 뭔지 알기
git checkout [브랜치이름] : 해당 브랜치로 이동하기
git checkout -b [브랜치이름] : 해당 브랜치를 만들고 이동하기
git branch -d [브랜치이름] : 해당 브랜치를 삭제하기
```

- 다른 브랜치에서 사용한 commit을 현재 브랜치에도 적용하고 싶은 경우

```cpp
git merge main // main branch에서 적용한 commit을 현재 branch에서도 적용하자.
```

- merge 도중 conflict가 발생할 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/956ff5d2-3ef3-459b-abde-09ddbf04fc0f/5a69e706-d785-4bfb-bd3c-8f32377eb8e7/Untitled.png)

→ conflict 발생시 해결방법

1. conflict가 발생한 파일을 연다
    1. merge의 결과가 되었으면 하는 모습대로 코드를 수정한다.
    2. 아예 merge를 취소하는 방법도 있음. 그럼 코드도 위 사진이 아니라 원래대로 돌아옴.
    
    ```cpp
    git merge --abort
    ```
    
2. 커밋한다.

→ 여러 file에서 conflict가 발생해도 당황하지 않고 파일 하나하나씩 충돌을 해결해주고 add 해주면 된다. 하나씩 add 해줘도 되고, 모든 파일을 수정한 후 한 번에 add 해줘도 된다.

### Branch에 대하여.

- 맨날 헷갈렸던 주요한 내용!
    
    # **1. origin이란?**
    
    먼저 첫 번째 커맨드를 봅시다.
    
    > git remote add origin https://github.com/kyuri-dev/Math_Box.git
    > 
    
    이 커맨드에서 **remote**는 리모트 레포지토리에 관한 작업을 할 때 쓰는 커맨드입니다.
    
    그리고 그 뒤의 **add**는 새로운 리모트 레포지토리를 등록하겠다는 뜻입니다.
    
    그 다음에는 **origin https://github.com/kyuri-dev/Math_Box.git**이라고 써있죠?
    
    이 표현은 **https://github.com/kyuri-dev/Math_Box.git** 리모트 레포지토리를 **origin**이라는 이름으로 등록하겠다는 뜻입니다.
    
    그러니까 이 커맨드를 실행하고 나면 **https://github.com/kyuri-dev/Math_Box.git**를 **origin**으로 간단하게 나타낼 수 있게 되는 거죠.
    
    그럼 왜 하필 **origin**이라고 하는 걸까요? origin이 아닌 여러분이 원하는 다른 단어를 입력해도 큰 상관은 없습니다. 하지만 Git에서는 리모트 레포지토리를 최초로 추가할 때 origin이라는 이름으로 가리키는 것이 관례화되어 있습니다.
    
    origin은 ‘근원’, ‘기원’이라는 뜻을 가집니다. 아마도 다른 사람의 리모트 레포지토리를 자신의 컴퓨터로 가져와서 작업을 하는 사람의 입장에서는 리모트 레포지토리가 프로젝트의 근원이 되는 존재이기 때문에 그런 관습이 생긴 것으로 추측됩니다.
    
    사실
    
    > git remote add hello https://github.com/kyuri-dev/Math_Box.git
    > 
    
    처럼 origin 대신 우리가 원하는 단어(hello)를 써도 상관은 없지만, 되도록 관례에 따라 origin을 써주는 게 좋겠죠?
    
    # **2. Remote Repositoy에 있는 브랜치**
    
    이제 두 번째 커맨드를 설명해드릴게요. - master → main으로 바뀜
    
    ```cpp
    git push -u origin main
    ```
    
    이 커맨드의 뜻은
    
    - 현재 로컬 레포지토리에 있는 master 브랜치의 내용(=master 브랜치와 관계된 모든 커밋들)을
    - origin이라는 리모트 레포지토리로 보낸다는 뜻입니다.
    
    이때 같은 이름의 브랜치로 전송하게 되는데 만약 origin이라는 리모트 레포지토리에 master 브랜치가 **없으면 master 브랜치를 새로 생성하고 푸시합니다.**
    그런데 여기서 옵션 **-u**는 무슨 뜻일까요? **-u**는 **--set-upstream**이라는 옵션의 약자입니다.
    
    이렇게 **--set-upstream(-u) 옵션**을 주면
    
    - 로컬 레포지토리에 있는 main 브랜치가
    - origin에 있는 master 브랜치를 **tracking(추적)**하는 걸로 설정됩니다.
    
    **tracking이라는 건 로컬 레포지토리의 한 브랜치가 리모트 레포지토리의 한 브랜치와 연결되어 그것을 계속 바라보는 상태가 되는 것**이라고 생각하시면 됩니다. 이렇게 맺어진 연결 상태를 **tracking connection**이라고 합니다.
    
    만약
    
    - 로컬 레포지토리에 A라는 브랜치가 있고,
    - 리모트 레포지토리에 B라는 브랜치가 있을 때
    - 이런 **tracking connection**이 서로 맺어진 경우,
    - B 브랜치를 A 브랜치의 **upstream branch**라고 합니다.
    - 지금은 구별하기 위해서 A와 B라고 표현했지만 보통은 같은 이름인 경우가 대부분입니다.
    
    이렇게 **tracking connection**이 한번 설정되고 나면,
    사용자가 현재 master 브랜치에 위치해있을 때,
    
    ```
    git push
    ```
    
    라고만 써도 자동으로 리모트 레포지토리의 master 브랜치를 대상으로 git push가 동작하고,
    
    ```
    git pull
    ```
    
    라고만 써도 리모트 레포지토리의 master 브랜치를 대상으로 git pull이 동작합니다.
    
    사실 **--set-upstream(-u)** 옵션을 주지 않아도 그 후에 git push와 git pull을 할 수 있기는 합니다. 하지만 맨 처음에 이 옵션을 주지 않으면 tracking connection이 없기 때문에 나중에 git push를 하고 싶을 때
    
    ```
    git push origin main:main
    ```
    
    이런 식으로 적어줘야 합니다. 여기서
    
    - origin은 리모트 레포지토리를 나타내고,
    - main:main에서 더 먼저 나오는 master는 로컬 레포지토리의 main 브랜치(~에서)/더 뒤에 나오는 master는 리모트 레포지토리의 main 브랜치(~으로)를 나타냅니다.
    
    그러니까 tracking connection이 없으면 매번 이런 식으로 git push를 해줘야 합니다. git pull도 마찬가지로 이런 식의 복잡한 표현이 필요하게 됩니다.
    
    그러니까 그냥 처음부터 tracking connection을 설정하고 그 이후부터는 git push, git pull이라고만 써서 편하게 푸시와 풀을 하는 게 좋겠죠? 이게 바로 제가 맨 처음에 로컬 레포지토리의 내용을 리모트 레포지토리로 보낼 때 -u라는 옵션을 썼던 이유입니다.
    
    # **3. origin/master의 의미**
    
    자, 이제
    
    - 로컬 레포지토리의 main 브랜치
    - 리모트 레포지토리의 main 브랜치
    
    이렇게 같은 이름이지만, 서로 다른 2개의 브랜치가 있다는 걸 알겠죠?
    
    그럼 리모트 레포지토리에 있는 master 브랜치는 어떻게 볼 수 있을까요? GitHub 페이지에서 보면 될 겁니다.
    
    하지만 제 컴퓨터에서도 확인할 수 있는 방법이 있습니다. 잠깐 커밋 히스토리를 살펴보면
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/42-1.png?1587001742169
    
    위 그림에서
    
    - **main**가 로컬 레포지토리의 main 브랜치를 나타내고
    - **origin/main**가 리모트 레포지토리의 main 브랜치를 나타냅니다.
    
    이때까지 로컬 레포지토리의 main브랜치에서 여러 커밋을 했지만 그러고나서 git push를 해준 적은 없었습니다. 그래서 위 그림처럼 **origin/master**가 **master**보다 이전의 커밋을 가리키고 있는 겁니다.
    
    다음 영상에서는 master, premium 브랜치 둘 다에서 리모트 레포지토리로 **git push** 하겠습니다. 그러고 나면 이제 origin/master도 master와 같은 커밋을 가리키게 될 것입니다.
    

### 서로 다른 branch에서 각각 push하기

- main branch는 이미 원격 레포에 존재해서 git push 하면 되지만 premium branch는 아직 없어서 추가적인 명령어가 필요하다.

```cpp
git push -u origin premium
```

이 명령어를 실행 시 원격 레포에 premium branch가 만들어지고, 여기에 해당 내용들이 전달된다.

### HEAD 와 branch의 관계

- head는 브랜치를 가리킬 뿐 직접적으로 커밋을 가리키지는 못한다. branch는 하나의 가닥이기도 하지만, 실제로 특정 커밋을 가리킨다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/956ff5d2-3ef3-459b-abde-09ddbf04fc0f/56ff838f-83cd-4a9f-8522-09d592de96e5/Untitled.png)

- 다른 브랜치를 하나 더 만들면 동일하게 5번째 커밋을 가리킨다. 이때 master 브랜치의 커밋과 새로 만든 브랜치에서의 커밋은 갈라서게 된다.  갈라선 상태에서 계속 커밋을 하다가 나중에 merge를 하면 하나의 브랜치로 통합하게 된다. 참고로 새로 만든 브랜치가 premium이라면

```cpp
git merge premium
```

을 실행하여 master 브랜치와 merge할 수 있음. 이때 premium 브랜치는 사라지는 듯

### git reset에 대해서

- git reset을 해서 과거의 커밋으로 돌아간다고 해도, 그 이후의 커밋이 삭제되는건 아니다.
- 꼭 과거로 돌아가는 것이 아니라, 그 이후의 커밋으로 이동할 수도 있다.

### git reset과 git checkout의 차이

- 차이 - 심화내용, 하지만 중요
    
    # **1. 이전 노트의 내용(git reset) 복습**
    
    이전 노트에서는 아래 그림과 같은 상태에서
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/46-1.png?1587009625701
    
    > git reset 9033
    > 
    
    를 실행하면
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/37-2.png?1587009639934
    
    이 그림과 같은 결과가 된다고 했습니다. 이렇게 HEAD는 **보통** 본인이 직접 커밋을 가리키는 게 아니라 브랜치를 통해서 **간접적으로 커밋을 가리킵니다.**
    
    # **2. git checkout이 하는 일**
    
    하지만 HEAD 자체가 가리키던 것을 바꿀 수도 있습니다. 사실 HEAD가 아예 커밋을 직접적으로 가리키게 하는 것도 가능한데요.
    
    바로 **git checkout** 커맨드를 쓰면 됩니다.
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/46-1.png?1587009625701
    
    원래의 이 상태에서
    
    > git checkout 9033
    > 
    
    를 실행하면 아래 그림처럼 바뀝니다.
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/27-3.png?1587009652246
    
    이 그림을 자세히 보세요. 이제 HEAD가 master 브랜치를 가리키는 게 아니라 본인이 직접 **9033.. 커밋**을 가리키고 있죠?
    
    이렇게 브랜치를 통해서 커밋을 가리키는 게 아니라 본인이 직접 커밋을 가리키고 있는 상태의 HEAD를 특별히 가리키는 말이 있습니다.
    
    바로 **Detached HEAD**입니다. Detached는 우리말로 ‘~로부터 떨어진, 분리된’이라는 뜻을 갖는데요. 브랜치로부터 떨어진 상태이기 때문에 이렇게 부르는 겁니다.
    
    이렇게 HEAD가 특정 커밋을 직접 가리키게 하는 이유는 여러가지가 있을 수 있는데요.
    
    그 중에서 주된 이유 한 가지는 바로 과거의 특정 커밋에서 새로운 브랜치를 만들고 싶을 때입니다.
    
    예를 들어 지금 위의 그림과 같이 Detached HEAD인 상태에서
    
    > git branch premium
    > 
    
    으로 premium 브랜치를 새로 만들면 아래 그림과 같은 결과가 됩니다.
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/25-4.png?1587009666417
    
    1. 지금 premium이라는 브랜치가 새로 생성되었고
    2. premium 브랜치는 HEAD가 가리키던 커밋을 똑같이 가리키게 됩니다.
    
    자, 그리고 여기서 새로운 사실을 하나 알려드릴게요.
    
    git checkout 커맨드로는
    
    - HEAD가 커밋을 직접적으로 가리키게 할 수도 있을 뿐만 아니라
    - 브랜치를 직접 가리키게 만들 수도 있습니다.
    
    HEAD가 브랜치를 가리키도록 해볼게요. 이렇게 쓰면
    
    > git checkout premium
    > 
    
    HEAD가 premium 브랜치를 가리키게 됩니다.
    
    그러니까 아래 그림과 같이 이제 HEAD가 premium 브랜치를 가리키게 되는 겁니다. 그리고 이것은 곧 Detached HEAD 상태에서 벗어나 HEAD가 브랜치를 가리키는 정상적인 상태로 돌아오는 거죠.
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/19-5.png?1587009679454
    
    그리고 이렇게 HEAD가 premium 브랜치를 가리키는 상태일 때 **새 커밋**을 하면
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/17-6.png?1587009690417
    
    **이제 premium 브랜치로 master 브랜치와 다른 새로운 코드 관리 흐름을 가져갈 수 있게 되는 겁니다.**
    
    방금 한 것처럼 특정 커밋을 시작점으로 하는 새로운 브랜치를 만들고 싶을 때 HEAD를 잠시 Detached HEAD 상태로 두는 경우가 많습니다.
    
    이 내용을 정리하면
    
    - git checkout 커맨드로는 HEAD가 직접적으로 가리키는 것을 바꿀 수 있고
    - git checkout 뒤에는 커밋 아이디 또는 브랜치의 이름을 줘서
    - HEAD가 직접 커밋을 가리키거나, 브랜치를 가리키도록 할 수 있다는 뜻입니다.
    
    그런데 사실 git checkout 뒤에 브랜치의 이름이 오는 경우는 이미 우리가 배웠습니다. 우리가 어떤 브랜치로 가고 싶을 때
    
    ```
    
    git checkout [가고 싶은 브랜치 이름]
    
    ```
    
    형식의 커맨드를 쓴다고 배웠죠?
    
    이제 이 커맨드가 좀 새로운 시각에서 느껴지지 않나요? 자, 그림으로 바로 보여드릴게요.
    
    지금 위 그림과 같은 상태에서
    
    > git checkout master
    > 
    
    를 실행하면
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/18-7.png?1587009703832
    
    이렇게 HEAD가 master 브랜치를 가리키게 됩니다. 바로 이게 우리가 이전에 **git checkout 커맨드를 사용해서 다른 브랜치로 이동할 때 벌어지는 일**이었던 겁니다.
    
    이렇게
    
    - HEAD가 다른 브랜치가 가리키던 커밋을 가리키게 되면
    - 그에 맞게 working directory 내부도 바뀌게 되고,
    - 그 결과 우리는 브랜치가 변경되었다는 걸 실감할 수 있었던 겁니다.
    
    이해하기 쉽게 다시 한번 풀어서 말하자면
    
    ```
    
    git checkout master
    
    ```
    
    이 커맨드의 뜻은 다음과 같이 해석됩니다.
    
    = master 브랜치로 이동하라
    
    = HEAD가 master 브랜치를 가리키도록 하라
    
    = HEAD가 master 브랜치가 가리키던 커밋을 간접적으로 가리키게 됨으로써
    
    = working directory의 내부도 그 커밋에 맞게 변함으로써
    
    = master 브랜치로 이동한 것을 사용자는 실감하게 됨
    
    이렇게 되는 거죠.
    
    자, git checkout의 비밀을 이제 알겠죠?
    
    # **3. git reset vs git checkout**
    
    마지막으로 git reset과 git checkout의 차이점을 짚고 넘어갈게요.
    
    둘의 차이점은 아래 표와 같습니다.
    
    | git reset | git checkout |
    | --- | --- |
    | HEAD가 가리키던 브랜치가 다른 커밋을 가리키도록 한다 | HEAD 자체가 다른 커밋이나 브랜치를 가리키도록 한다 |
    | HEAD도 결국 간접적으로 다른 커밋을 가리키게되는 효과가 생긴다 | 브랜치를 통하지 않고, 커밋을 직접적으로 가리키는 HEAD를 Detached HEAD라고 한다 |

### merge의 다양한 종류(Fast-forward 머지, 3-way 머지)

- 새 커밋을 만들지 않는 머지
    
    **머지(merge)**에 관한 좀더 깊은 이야기를 해볼게요. 머지를 하면 새로운 커밋이 생긴다고 했습니다.
    
    그리고 머지를 통해서 생겨난 커밋을 **머지 커밋(merge commit)**이라고 부른다고 했는데요.
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/56-1.png?1587447071140
    
    이 그림을 보면 지금 **master 브랜치에서 premium 브랜치를 머지**해서 검은색의 머지 커밋이 생긴 것을 알 수 있습니다.
    
    하지만 머지를 한다고 항상 이렇게 새로운 커밋이 생기는 건 아닙니다.
    
    아래 그림를 보세요.
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/48-1.png?1587021269169
    
    지금 저는 master 브랜치에 있죠? HEAD가 master 브랜치를 가리키고 있으니까요. 이 상태에서
    
    > git merge premium
    > 
    
    을 실행하면 어떻게 될까요?
    
    그럼 이렇게 됩니다.
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/39-2.png?1587021283608
    
    premium 브랜치가 가리키던 커밋을, master 커밋도 똑같이 가리키게 되는데요. 지금 총 커밋 수는 그대로죠?
    
    이렇게 새로운 커밋이 생기는 게 아니라 단지 브랜치가 이동하게 되는 머지를 **Fast-forward 머지**라고 합니다. Fast-forward는 어떤 영상이나 소리를 **빨리감기**(앞으로 감기)한다는 뜻인데요. 지금 master 브랜치가 더 최신 커밋으로 이동하는 모습이 꼭 빨리감기같죠?
    
    어떤 경우에 이렇게 되는 걸까요?
    
    커밋 히스토리에서 같은 선(line) 상에 있는 브랜치를 머지할 때 Fast-forward 머지가 이루어집니다. 방금 전에는 master 브랜치와 premium 브랜치가 둘다 같은 선 상에 있었죠? 바로 이런 경우입니다.
    
    하지만 노트 초반부에서 봤던
    
    !https://codeit-images.s3.ap-northeast-2.amazonaws.com/images/5e345231f974fb2074b368c1/29-4.png?1587027709982
    
    이 그림처럼 두 브랜치가, 커밋 히스토리 상에서 분리된 2개의 선에 각각 존재할 때 머지를 하면 머지 커밋이 새롭게 생기는 거구요. .
    
    그리고 이런 머지는 **3-way merge**라고 합니다. **이름이 3-way인 이유는 지금 1, 2, 3 표시한 3가지 커밋을 고려해서 머지를 하기 때문입니다.** 지금 각각
    
    - (1)번 : 두 갈래로 갈라지기 전 공통 조상이 되는커밋
    - (2)번 : 한 브랜치가 가리키는 커밋
    - (3)번 : 다른 브랜치가 가리키는 커밋
    
    인데요. **3-way merge는 자신만의 방식을 갖고 이 3가지 커밋을 기준으로 머지 커밋을 자동으로 만들어냅니다.**
    
    그 방식에 대해서 간단하게 알려드릴게요. 아래 표에는 master 브랜치와 premium 브랜치를 머지했을 때 다양한 상황별로 그 결과가 정리되어 있는데요.
    
    | 경우 | base | master | premium |  | 머지 결과 |
    | --- | --- | --- | --- | --- | --- |
    | case1 | A | A | B | -> | B |
    | case2 | 1 | 2 | 1 | -> | 2 |
    | case3 | "hello" | (공백) | "hello" | -> | (공백) |
    | case4 | "bye" | "fighting" | "please" | -> | Conflict 발생! |
    
    각 컬럼(column, 열)에 대해서 설명할게요. 지금 모든 커밋에 sample.txt 파일이 있다고 가정할게요.
    
    1. **base** : 두 브랜치의 공통 부모 커밋의 sample.txt 파일의 내용 중 일부 = 위 그림 (1)번
    2. **master** : 마스터 브랜치의 최신 커밋의 sample.txt 파일의 내용 중 일부 = 위 그림 (2)번
    3. **premium** : 프리미엄 브랜치의 sample.txt 파일의 내용 중 일부 = 위 그림 (3)번
    4. **머지 결과** : master 브랜치에서 premium 브랜치를 머지했을 때의 최종 결과
    
    자, 각각의 경우에 왜 표와 같은 머지 결과가 생기는 건지 설명해드릴게요.
    
    **case1**
    
    지금 base가 A이고, master는 A, premium은 B죠? 그럼 base를 기준으로 볼 때, master에서는 변화가 없었지만, premium에서는 A가 B로 변경된 상태입니다. **3-way merge는 base에서 변화가 발생한 것을 우선 채택**합니다. 그래서 머지 결과는 'B'가 됩니다.
    
    **case2**
    
    지금 base가 1이고, master는 2, premium은 1이죠? 이 경우에도 base에서 변화가 발생한 2가 머지 결과가 됩니다.
    
    **case3**
    
    지금 base가 "hello"이고, master는 "hello"를 삭제한 공백 상태, premium은 "hello"입니다. "hello"를 삭제해서 공백 상태가 된 것이 변화가 더 발생한 것이기 때문에 머지 결과는 공백이 됩니다.
    
    **case4**
    
    지금 base가 "bye", master가 "fighting", premium이 "please" 인데요. 지금은 이전 경우들과 좀 다르네요. 둘 다 base 때와는 다른 변화가 일어났는데요. 이렇게 두 브랜치에서 다 변화가 있을 때 Git은 어떤 변화를 선택해야할까요? 정답은 바로 '**Git도 모른다!**' 입니다. 사실, 바로 이런 경우에 여러분이 배운 **Conflict가 발생**합니다. 이전에 Conflict가 발생했을 때 그것을 해결하고 머지를 마무리했던 거 기억나시죠? 바로 이런 경우였던 겁니다.
    
    3-way merge가 어떤 방식으로 이루어지는지 아시겠죠?
    
    - base때의 내용과 비교했을 때 달라진 부분이 있는 것이 우선시되고,
    - 두 브랜치에서 둘다 변화가 일어났을 때는 Conflict를 발생시켜서 사용자가 스스로 선택하게끔 한다는 걸 기억하시면 됩니다.
    
    자, 이때까지 머지에 대해서 좀 깊게 배워봤습니다. 방금 배운 내용을 다 기억하지 못하더라도
    
    머지의 종류에는 크게
    
    - **Fast-forward 머지**
    - **3-way 머지**
    
    이렇게 두 가지 종류가 있다는 사실만큼은 꼭 기억하세요.
    

### Git 명령어 정리

- **git branch [새 브랜치 이름]**: 새로운 브랜치를 생성
- **git checkout -b [새 브랜치 이름]**: 새로운 브랜치를 생성하고 그 브랜치로 바로 이동
- **git branch -d [기존 브랜치 이름]**: 브랜치 삭제
- **git checkout [기존 브랜치 이름]**: 그 브랜치로 이동
- **git merge [기존 브랜치 이름]**: 현재 브랜치에 다른 브랜치를 머지
- **git merge --abort**: 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감

### git push하기 전에 git pull을 해야 하는 경우가 많을 겁니다.

git pull을 해서 혹시 원격 레포지토리에 있는 변경사항을 가져오고 나서, pull을 해야지 에러가 발생하지 않는다.

그런데 git pull도 충돌이 발생해서 잘 안되는 경우가 있다. 이럴 때는 상황에 맞게 충돌을 해결한 후 다시 pull을 진행하면 된다.

여기서 git pull은 원격 저장소에서 정보를 가져옴과 동시에 merge를 진행한다. - git fetch와의 차

### git pull 말고 git fetch?

- git fetch는 원격 저장소에서 정보를 가져오기만 하고 merge는 하지 않는다.

git fetch가 필요한 이유?

1. 원격 레포지토리에서 가져온 정보가 맞는지 점검해야할 필요가 있는 경우
2. 원격 레포지토리에서 가져온 정보가 내가 작성한 코드와 비교해서 잘 못된 부분이 있는지 체크해야 될때 사용한다.

→ git fetch를 한 후에 git diff 기능을 이용해서 기존과 차이점이 무엇인지 확인 할 수 있다.

### git blame을 이용해서 잘못쓴 범인 찾기

- 커밋을 하다보면 누가 이 코드를 작성했는지 알고 싶은 경우가 있다. 이럴 때는 git blame을 사용한다. 이걸 사용하면 누가 했는지 알 수 있음. 이를 통해 해당 커밋의 id를 알 수 있고, 이를 통해 git show [커밋id]를 실행하면 범인을 더 자세히 알 수 있다.

### 이미 원격 저장소에 올라간 커밋을 취소하고 싶은 경우?

- 이런 경우에는 그냥 로컬에서 수정하고 싶은 내용을 수정해서 다시 push를 진행하면 된다.
- 하지만 이 과정을 한번에 해주는 명령어가 있으니 바로 git revert이다.

```cpp
git revert [되돌리고싶은 커밋id]
```

이렇게 작성하면 이미 올라간 커밋을 취소할 수 있다. 한 번에 여러 개를 revert 할 수도 잇는데,

```cpp
git revert [되돌리고싶은 커밋id 하나 전]..[되돌리고 싶은 마지막 커밋id]
# 만약 3,4,5,6번을 취소하고 싶다면 2..6을 해야한다.
```

이렇게 실행하면 하나하나 전부 commit message를 작성해서 수정할 수 있다.

### Git 협업하기 정리

- **git fetch**: 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)
- **git blame**: 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력
- **git revert**: 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성

### Git reset 하면 커밋들이 전부 없어지나?

과거의 커밋으로 git reset을 하면 내가 했던 커밋들이 모두 없어지나? 그렇지는 않다. 커밋id만 알고있다면 언제든지 되돌아 갈 수 있다. 그런데 커밋 아이디를 쉽게 알 수 있는 방법이 있나? 바로 

```cpp
git reflog
```

이다. 이거 작성하면 그동안 Head가 가리켰던 커밋들의 id들을 쭉 보여준다. 실무에서 유용하니 꼭 알아두자.

### 커밋 히스토리를 보는 다양한 방법

```cpp
git history --all # 모든 브랜치에 해당하는 커밋을 볼 수 있음
git history --all --graph # 그래프 그림으로 확인 할 수 있음.
```

그림으로 확인하면 좀 더 가시적으로 확인할 수 있어 좋다.

### git merge 보다 git rebase는 어때?

- git merge는 2개의 브랜치를 하나로 합쳐지는 과정이 있음. (그래프로 나타내면 2개의 브랜치가 한 곳에서 만나는 점이 존재)
- git rebase의 경우에는 아예 처음부터 하나의 브랜치에서 했던 것 처럼 바꿔준다. 좀 더 깔끔한 면이 있다.
- 둘이 결과물이 같기는 하지만 커밋 히스토리를 더 이쁘게 만들 수 있음. 상황에 맞게 2개 중 하나를 사용하면 된다.

### 작업 내용을 임시로 저장해야 할 때

```cpp
git stash # 미완성된 작업물을 stack에 저장하고 가장 최근 커밋의 내용으로 바꿔둔다.
git stash list # stack에 뭐가 들어있는지 확인 가능.
git stash apply # 다른 작업 후 stack에 있는 내용을 다시 불러오고 싶은 경
```

어떤 작업을 하던 중 다른 브랜치로 이동해서 바로 작업해야 하는 경우에 사용한다. 그럼 작업하던 내용을 스택에 저장하고 현재 내용은 가장 최근 커밋의 내용으로 바꾸어준다.

### 잘 못된 브랜치에서 작업을 하고 있었을 경우

작업한 내용을 그래도 git stash를 이용해 스택에 저장한 후 올바른 브랜치로 이동해서 

git stash apply [해당번호] 을 해주면 된다. 이때 충돌이 발생한 경우 직접 코드를 수정하는 식으로 충돌을 없애주고 add, commit을 해주면 된다.

이때 stack에는 지금까지 넣어둔 여러 자료가 있으므로 보통 사용하고

```cpp
git stash drop
```

을 이용해서 스택에서 제거해주는 것이 일반적이다.

그런데 사실 이런 식으로 번거롭게 할 필요없이, 작업 내용을 적용하면서 동시에 스택에서 제거도 해주는 커맨드가 있습니다.

```

git stash pop [작업 내용의 아이디]

```

이라는 커맨드입니다. 이 커맨드를 쓰면 특정 작업 내용을 적용함과 동시에 그것을 스택에서 제거합니다. 보통은 이렇게 쓰자마자 제거해주는게 일반적이며, 나중에 여러 번 쓰여야 하는 정보는 pop하지 않는다.

### git cherry-pick [커밋id]

원하는 커밋부분만 따로 골라내어 가져올 수 있다.

예를 들어 내가 여러 실험을 한다고 하자. 실험1,2,3,…100. 그중에서 실험34가 제일 성능이 좋다고 해서 이 내용을 다시 가져오고 싶어 한다. 그러면 

```cpp
git cherry-pick [실험34]
```

를 실행해서 원하는 내용만 가져올 수 있다.

### 여러 개의 커밋을 하나의 커밋으로 만들기

내가 실험 0,1,2를 순서대로 진행하고 커밋을 했는데 알고보니 실험2만 사용하고 실험1은 안 사용한다고 하자. 그럼 실험 0으로 git reset —soft [실험0] 을 하고, 그 다음 바로 add를 진행하면, 실험1은 없어지고 실험 2만 add되게 된다. (soft가 아니라 mixed여도 될듯. hard만 아니면 됨)

아 **물론 실험1 커밋은 아예 삭제가 되는 것은 아니므로 git reflog 을 이용해서 확인해볼 수 있다.**

### git이 무시하는 파일들 = .gitignore 파일

- git 이 따로 버전관리를 안해도 되고, 하면 용량 낭비만 되는 파일들의 이름 형식들을 모두 여기에 보관하면 된다. 그러면 여기 안에 필터링되는 이름을 가진 자료들은 git이 상관하지 않는다. 추후에 추가되거나 수정된다 하더라도, add 해도 반영되지 않는 등 관리하지 않는다.

### Git 강의에서 배운 명령어 총정리

- 총정리
    
    ## **2. Git 써보기**
    
    - **git init** : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성
    - **git config** **user.name 'codeit'** : 현재 사용자의 아이디를 'codeit'으로 설정(커밋할 때 필요한 정보)
    - **git config user.email 'teacher@codeit.kr'** : 현재 사용자의 이메일 주소를 'teacher@codeit.kr'로 설정(커밋할 때 필요한 정보)
    - **git add [파일 이름]** : 수정사항이 있는 특정 파일을 staging area에 올리기
    - **git add [디렉토리명]** : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기
    - **git add .** : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기
    - **git reset [파일 이름]** : staging area에 올렸던 파일 다시 내리기
    - **git status** : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)
    - **git commit -m "커밋 메시지"** : 현재 staging area에 있는 것들 커밋으로 남기기
    - **git help [커맨드 이름]** : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력
    
    ## **3. GitHub 시작하기**
    
    - **git push -u(또는 --set-upstream) origin master** : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.
    - **git push** : 위의 커맨드를 한번 실행하고 난 후에는 git push라고만 쳐도 로컬 레포지토리의 내용을 리모트 레포지토리에 올릴 수 있습니다.
    - **git pull** : 바로 위의 위에 있는 커맨드를 한번 실행하고 난 후에는 git pull이라고만 쳐도 리모트 레포지토리의 내용을 로컬 레포지토리로 가져옵니다.
    - **git clone [프로젝트의 GitHub 상 주소]** : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기
    
    ## **4. Git에서 커밋 다루기**
    
    - **git log** : 커밋 히스토리를 출력
    - **git log --pretty=oneline** : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 **[이 링크](https://git-scm.com/docs/pretty-formats)**를 참고하세요.
    - **git show [커밋 아이디]** : 특정 커밋에서 어떤 변경사항이 있었는지 확인
    - **git commit --amend** : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦
    - **git config alias.[별명] [커맨드]** : 길이가 긴 커맨드에 별명을 붙여서 이후로는 별명으로도 해당 커맨드를 실행할 수 있게 설정
    - **git diff [커밋 A의 아이디] [커밋 B의 아이디]** : 두 커밋 간의 차이 비교
    - **git reset [옵션] [커밋 아이디]** : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)
        
        (1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)
        
        (2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)
        
        (3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)
        
        그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨
        
    - **git tag [태그 이름] [커밋 아이디]** : 특정 커밋에 태그를 붙임
    
    ## **5. Git에서 브랜치 사용하기**
    
    - **git branch [새 브랜치 이름]** : 새로운 브랜치를 생성
    - **git checkout -b [새 브랜치 이름]** : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동
    - **git branch -d [기존 브랜치 이름]** : 브랜치 삭제
    - **git checkout [기존 브랜치 이름]** : 그 브랜치로 이동
    - **git merge [기존 브랜치 이름]** : 현재 브랜치에 다른 브랜치를 머지
    - **git merge --abort** : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감
    
    ## **6. Git 실전 I**
    
    - **git fetch** : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)
    - **git blame** : 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력
    - **git revert** : 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성
    
    ## **7. Git 실전 Ⅱ**
    
    - **git reflog** : HEAD가 그동안 가리켜왔던 커밋들의 기록을 출력
    - **git log --all --graph** : 모든 브랜치의 커밋 히스토리를, 커밋 간의 관계가 잘 드러나도록 그래프 형식으로 출력
    - g**it rebase [브랜치 이름]** : A, B 브랜치가 있는 상태에서 지금 HEAD가 A 브랜치를 가리킬 때, g**it rebase B**를 실행하면 A, B 브랜치가 분기하는 시작점이 된 공통 커밋 이후로부터 존재하는 A 브랜치 상의 커밋들이 그대로 B 브랜치의 최신 커밋 이후로 이어붙여짐(git merge와 같은 효과를 가지지만 커밋 히스토리가 한 줄로 깔끔하게 된다는 차이점이 있음)
    - **git stash** : 현재 작업 내용을 스택 영역에 저장
    - **git stash apply [커밋 아이디]** : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 working directory에 적용
    - **git stash drop [커밋 아이디]** : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 스택에서 삭제
    - **git stash pop [커밋 아이디]** : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 working directory에 적용하면서 스택에서 삭제
    - **git cherry-pick [커밋 아이디]** : 특정 커밋의 내용을 현재 커밋에 반영
    
    **! 그 밖에 알아야할 사실**
    
    (1) **git commit**이라고만 쓰고 실행하면 커밋 메시지를 입력할 수 있는 텍스트 에디터 창이 뜹니다. 거기서 커밋 메시지를 입력하고 저장하고 나면 커밋이 이루어집니다.
    
    (2) **git push**와 **git pull**은 그 작업 단위가 브랜치입니다. 예를 들어, master 브랜치에서 git push를 하면 master 브랜치의 내용만 리모트 레포지토리의 master 브랜치로 전송되지, premium 브랜치의 내용이 전송되는 것은 아닙니다.(git push에 --all이라는 옵션을 주면 모든 브랜치의 내용을 전송할 수 있기는 합니다.)