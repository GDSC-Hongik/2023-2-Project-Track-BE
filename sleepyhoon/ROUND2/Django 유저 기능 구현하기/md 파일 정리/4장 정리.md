# 4장 접근제어

### 접근제어가 필요한 이유?

- 로그인을 하지 않았는데, 리뷰를 작성할 수 있다거나, 리뷰를 삭제할 수 있는 상황이 생긴다. 이 경우에는 접근제어를 필요로 한다.

접근제어는 mixin으로 해결한다. 따로 설치할 필요도 없고, django-contrib-auth를 import하면 된다. 근데 여기는 우리 맘대로 커스텀하기가 힘들기 때문에 다른 것을 사용할 계획이다. 바로 django-braces의 access mixin을 사용한다.

참고로 함수형 뷰에서는 decorator를 사용하고, 클래스형 뷰에서는 mixin을 사용한다. 

```python
# mixin을 매개변수에 넣을때는 반드시 mixin을 왼쪽에 위치시켜야한다.
class ReviewCreateView(LoginRequiredMixin, UserPassesTestMixin,CreateView): 
# 로그인에서 mixin을 넣어줌(접근제어 필요)
    model = Review
    form_class = ReviewForm
    template_name = "coplate/review_form.html"
```

mixin의 위치를 조심하자. mixin 사이에도 순서가 중요하다. 로그인을 먼저 확인한 다음에 이메일 인증을 했는데 확인해야 한다.

- 또한 이메일 인증을 받은 사람만 리뷰 작성을 할 수 있도록 하는 것이 좋을 거 같다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/956ff5d2-3ef3-459b-abde-09ddbf04fc0f/9dc8d05e-8b8a-47b3-8759-fd6fa68d63be/Untitled.png)

```python
def test_func(self, user):
        # "유저가 등록되어 있고, 인증된 것이 존재한다면" 이라고 해석
        return EmailAddress.objects.filter(user=user, verified = True).exists()
```

## 2가지 접근제어 코드 정리

```python
redirect_unauthenticated_users = False
raise_exception = True
```

- redirect_unauthenticated_users
    - True : 로그인이 안된 유저는 로그인 페이지로 안내해준다.
    - False : 아무 행동을 하지 않는다 → raise_exception 값에 따라서 처리한다.
- raise_exception
    - True : 권한이 없는 경우 403 에러 페이지를 출력한다.
    - False : 예외가 발생해도 아무일도 일어나지 않는다. 보통 True로 설정하여 예외처리를 한다.
    - 추가적으로 개인이 함수를 선언하여 대입해줄 수 있다.(아래 토글에서 언급)

자세한 내용은 mixin 내용을 정리할 때 다시 한 번 언급한다.

## mixin?

- mixin 내용 정리
    
    # **Mixin이란?**
    
    Mixin은 파이썬의 일반적인 개념인데, 기존의 클래스에 어떤 기능을 더해줄 때 쓰입니다. 우리의 경우 mixin을 활용해서 뷰 클래스에 접근 제어 기능을 더해줬습니다.
    
    우리는 django-braces(링크 추가)라는 패키지를 사용했는데요. django-braces는 사실 django에서 사용할 수 있는 다양한 mixin을 제공합니다. 우리는 그중에서 `LoginRequiredMixin`과 `UserPassesTestMixin`을 사용해 봤습니다.
    
    # **`LoginRequiredMixin`**
    
    `LoginRequiredMixin`은 로그인이 돼있는 유저만 뷰에 접근할 수 있게 해 줍니다. 로그인 여부를 확인하는 로직이 뷰 로직보다 먼저 실행돼야 하기 때문에 제네릭 뷰 왼쪽에 씁니다.
    
    ```python
    
    class MyView(LoginRequiredMixin, CreateView):
        ...
    
    ```
    
    로그인이 안 돼있으면 로그인 페이지(settings 파일의 `LOGIN_URL`에 해당하는 URL)로 리디렉트되고, 로그인을 한 후에는 원래 가려고 하던 페이지로 또다시 리디렉트됩니다.
    
    # **`UserPassesTestMixin`**
    
    (로그인 여부가 아닌) 어떤 특정 조건을 충족하는지 확인하고 싶을 때는 `UserPassesTestMixin`을 씁니다. `UserPassesTestMixin`은 우리가 정의하는 커스텀 테스트 (`test_func`)를 통과하는 유저만 뷰에 접근할 수 있게 해 줍니다.
    
    `UserPassesTestMixin`을 따로 쓸 수도 있지만, 보통 유저가 로그인이 돼있는지를 먼저 확인하기 때문에 (그래야 그 유저에 대한 여러 가지 조건을 확인할 수 있겠죠?) `LoginRequiredMixin`과 같이 씁니다. `LoginRequiredMixin` 오른쪽, 제네릭 뷰 왼쪽에 써 주시면 됩니다.
    
    ```python
    
    class MyView(LoginRequiredMixin, UserPassesTestMixin, CreateView):
        ...
    
    ```
    
    ## **`test_func`**
    
    `test_func`는 뷰에 접근할 수 있으면 `True`, 없으면 `False`를 리턴합니다.
    
    ```python
    
    class MyView(LoginRequiredMixin, UserPassesTestMixin, CreateView):
        def test_func(self, user):
            if <condition>:
                return True
            else:
                return False
    
    ```
    
    이걸 더 간단히 써 줄 수도 있고요.
    
    ```python
    
    class MyView(LoginRequiredMixin, UserPassesTestMixin, CreateView):
        def test_func(self, user):
            return <condition>
    
    ```
    
    ## **뷰에 접근하지 못하는 유저들 처리하기**
    
    뷰에 접근하지 못하는 유저가 처리되는 방식을 제어하기 위해서는 두 가지 속성을 사용합니다.
    
    1. `redirect_unauthenticated_users`
    
    뷰에 접근하지 못하는 유저들 중, 로그인 돼있는 유저와 로그인이 안 돼있는 유저를 다르게 처리할 것인지를 정하는 속성입니다. 이걸 `True`로 하면, 로그인이 안 돼있는 유저는 로그인 페이지로 리디렉트되고, 로그인 돼있는 유저는 `raise_exception` 속성의 값에 따라 처리 방식이 정해집니다. 반대로 이걸 `False`로 하면, 로그인 돼있는 유저 안 돼있는 유저 모두 `raise_exception` 속성의 값에 따라 처리됩니다.
    
    1. `raise_exception`
    
    `raise_exception`에 가장 흔히 사용되는 값은 `True`와 커스텀 함수인데요. `raise_exception`을 `True`로 설정해 주면 유저가 뷰에 접근할 수 없을 경우 403 Forbidden(권한 없음, 금지됨) 오류가 나고, 커스텀 함수로 설정해 주면 그 함수가 그대로 실행됩니다.
    
    ```python
    
    def some_func(self, request):
        # 필요한 로직 수행
        return redirect('some_url')
    
    class ReviewCreateView(LoginRequiredMixin, UserPassesTestMixin, CreateView):
        ...
        raise_exception = some_func
    
    ```
    
    커스텀 함수는 `self`와 `request`를 파라미터로 받아야 합니다.
    

## 추가적으로 decorator?

- decorator?
    
    `LoginRequiredMixin`과 비슷한 역할을 하는 `login_required` decorator가 있는데, 아래와 같이 임포트할 수 있습니다.
    
    ```python
    
    from django.contrib.auth.decorators import login_required
    
    ```
    
    그리고 decorator를 뷰 위에 달아주면 됩니다.
    
    ```python
    
    # views.py
    from django.contrib.auth.decorators import login_required
    
    @login_required
    def my_view(request):
        ...
    
    ```
    
    그러면 로그인이 안 돼있는데 `my_view`를 접근하려고 하면 로그인 페이지(settings 파일의 `LOGIN_URL`에 해당하는 URL)로 리디렉트됩니다.
    
    참고로 decorator는 뷰를 정의할 때가 아닌 URL 패턴을 정의할 때 사용할 수도 있는데요.
    
    ```python
    
    # views.py
    def my_view(request):
        ...
    
    class YourView(View):
        ...
    
    # urls.py
    from django.contrib.auth.decorators import login_required
    
    from .views import my_view, YourView
    
    urlpatterns = [
        path('my/url/', login_required(my_view), name='my_url'),
        path('your/url/', login_required(YourView.as_view()), name='your_url'),
    ]
    
    ```
    
    뷰를 decorator로 감싸주면 됩니다. (`YourView`는 클래스형 뷰지만 `.as_view()` 메소드를 적용해 주면 decorator를 사용할 수 있습니다.) 위와 같은 방식도 많이 사용됩니다. 뷰를 직접 정의하는 것이 아니라 뷰를 임포트해서 URL 패턴에 사용한다면 유용할 수 있겠죠?
    
    `UserPassesTestMixin`과 비슷한 `user_passes_test` decorator도 있는데요. `user_passes_test`는 뷰에 접근하지 못하는 유저를 처리하는 로직을 커스터마이즈할 수 없다는 단점이 있습니다. `user_passes_test`는  뷰에 접근하지 못하는 유저를 어떤 URL로 리디렉트하는 로직밖에 구현할 수 없습니다. (자세한 사용법은 [링크](https://docs.djangoproject.com/en/2.2/topics/auth/default/#limiting-access-to-logged-in-users-that-pass-a-test)를 참고하세요!) 다른 로직이 필요하다면 로직을 함수형 뷰 안에 직접 넣거나 클래스형 뷰를 사용해야겠죠?
    
    → 결국 mixin에 비해 기능적으로 커스텀하기 힘들다는 단점이 존재하는 것 같다.